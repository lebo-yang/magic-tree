<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled Christmas Tree</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Helvetica Neue', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* UI å±‚ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        .hud-text {
            color: rgba(255, 215, 0, 0.8); text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            text-transform: uppercase; letter-spacing: 2px; font-size: 14px;
        }

        #controls { pointer-events: auto; text-align: center; margin-bottom: 20px;}
        
        /* æ‘„åƒå¤´é¢„è§ˆï¼ˆç”¨äºè°ƒè¯•ï¼Œå®é™…å¯éšè—æˆ–åšæˆHUDé£æ ¼ï¼‰ */
        .input_video {
            position: absolute; bottom: 20px; right: 20px; width: 160px; height: 120px; 
            border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 8px; opacity: 0.7; transform: scaleX(-1);
        }

        /* ä¸Šä¼ æŒ‰é’® */
        .upload-btn {
            background: rgba(47, 79, 79, 0.8); border: 1px solid #FFD700; color: #FFD700;
            padding: 10px 20px; cursor: pointer; font-weight: bold; transition: 0.3s;
            pointer-events: auto; display: inline-block; margin-top: 10px;
        }
        .upload-btn:hover { background: #FFD700; color: #000; box-shadow: 0 0 15px #FFD700; }
        
        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        #status-indicator {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 24px; color: white; opacity: 0; transition: opacity 0.5s;
            text-shadow: 0 0 20px rgba(255,255,255,0.8); pointer-events: none;
        }

        /* å…‰æ ‡ */
        #hand-cursor {
            position: absolute; width: 20px; height: 20px; border: 2px solid #FFD700; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; display: none;
            box-shadow: 0 0 10px #FFD700; transition: width 0.2s, height 0.2s;
        }
        #hand-cursor.pinching { background-color: rgba(255, 0, 0, 0.5); width: 10px; height: 10px; }
    </style>
</head>
<body>

    <video class="input_video" playsinline></video>
    
    <div id="ui-layer">
        <div class="hud-text">
            System Status: Online<br>
            Mode: <span id="mode-text">Tree (Closed)</span>
        </div>
        
        <div id="status-indicator"></div>
      <div id="music-player" style="position: absolute; bottom: 100px; right: 20px; z-index: 20; opacity: 0.8;">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=280 height=86 
        src="//music.163.com/outchain/player?type=2&id=2657777735&auto=1&height=66">
    </iframe>
     </div>

        <div id="controls">
            <div class="hud-text" style="margin-bottom:10px; font-size: 12px; color: #aaa;">
                äº¤äº’æŒ‡å—: âœŠ åˆæ‹¢ | ğŸ– æ•£å¼€/æ—‹è½¬ | ğŸ‘Œ æŠ“å–ç…§ç‰‡
            </div>
            <label class="upload-btn">
                ä¸Šä¼ ç…§ç‰‡ (å¤šé€‰)
                <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
            </label>
        </div>
    </div>

    <div id="hand-cursor"></div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
                "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js",
                "@mediapipe/drawing_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'gsap';

        // --- å…¨å±€å˜é‡é…ç½® ---
        const CONFIG = {
            colors: {
                green: 0x2F4F4F, // å“‘å…‰ç»¿
                gold: 0xFFD700,  // é‡‘
                red: 0x8B0000,   // åœ£è¯çº¢
                white: 0xFFFFFF
            },
            particleCount: 400,
            spreadRadius: 30, // æ•£å¼€çŠ¶æ€çš„èŒƒå›´
            treeHeight: 25,
            treeRadius: 10
        };

        let camera, scene, renderer, composer, controls;
        let particles = []; // å­˜å‚¨æ‰€æœ‰ 3D å¯¹è±¡çš„æ•°æ®ç»“æ„
        let uploadedTextures = []; // å­˜å‚¨ç”¨æˆ·ä¸Šä¼ çš„ç…§ç‰‡çº¹ç†
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2(); // ç”¨äºæ‰‹åŠ¿æ˜ å°„çš„åæ ‡
        
        // çŠ¶æ€ç®¡ç†
        const STATE = {
            TREE: 'tree',
            SCATTER: 'scatter',
            FOCUS: 'focus'
        };
        let currentState = STATE.TREE;
        let focusTarget = null; // å½“å‰æ”¾å¤§çš„ç…§ç‰‡å¯¹è±¡

        // --- åˆå§‹åŒ– Three.js ---
        function init() {
            const container = document.getElementById('canvas-container');

            // åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 40);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // åå¤„ç† (è¾‰å…‰)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2; // è¾‰å…‰å¼ºåº¦
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(CONFIG.colors.gold, 2, 100);
            pointLight.position.set(0, 20, 10);
            scene.add(pointLight);
            
            const spotLight = new THREE.SpotLight(0xffffff, 5);
            spotLight.position.set(20, 50, 20);
            spotLight.angle = 0.3;
            spotLight.penumbra = 0.5;
            scene.add(spotLight);

            // è½¨é“æ§åˆ¶å™¨ (ä¸»è¦ç”¨äºè°ƒè¯•ï¼Œæ‰‹åŠ¿æ§åˆ¶æ—¶ä¼šæ¥ç®¡)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;

            // ç”Ÿæˆé»˜è®¤ç²’å­
            generateParticles();

            // äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
            
            animate();
        }

        // --- æ ¸å¿ƒï¼šç²’å­ä¸å†…å®¹ç”Ÿæˆ ---

        class ParticleObject {
            constructor(mesh, type) {
                this.mesh = mesh;
                this.type = type; // 'deco' or 'photo'
                
                // è®¡ç®— Tree çŠ¶æ€ä¸‹çš„ç›®æ ‡ä½ç½® (åœ†é”¥èºæ—‹)
                // éšæœºé«˜åº¦
                const y = (Math.random() * CONFIG.treeHeight) - (CONFIG.treeHeight / 2) + 5; 
                // åŠå¾„éšé«˜åº¦å˜å°
                const percent = 1 - ((y + CONFIG.treeHeight/2 - 5) / CONFIG.treeHeight);
                const r = percent * CONFIG.treeRadius + Math.random(); 
                // è§’åº¦
                const theta = y * 2 + Math.random() * Math.PI * 2;
                
                this.treePos = new THREE.Vector3(
                    r * Math.cos(theta),
                    y,
                    r * Math.sin(theta)
                );

                this.treeRot = { x: Math.random() * Math.PI, y: Math.random() * Math.PI, z: Math.random() * Math.PI };

                // è®¡ç®— Scatter çŠ¶æ€ä¸‹çš„ç›®æ ‡ä½ç½® (çƒå½¢éšæœº)
                const u = Math.random();
                const v = Math.random();
                const theta2 = 2 * Math.PI * u;
                const phi = Math.acos(2 * v - 1);
                const r2 = 10 + Math.random() * CONFIG.spreadRadius;
                
                this.scatterPos = new THREE.Vector3(
                    r2 * Math.sin(phi) * Math.cos(theta2),
                    r2 * Math.sin(phi) * Math.sin(theta2),
                    r2 * Math.cos(phi)
                );
                
                this.scatterRot = { x: Math.random() * Math.PI * 2, y: Math.random() * Math.PI * 2, z: Math.random() * Math.PI * 2 };

                // åˆå§‹è®¾ç½®
                this.mesh.position.copy(this.treePos);
                scene.add(this.mesh);
            }

            updateToState(stateName) {
                let targetPos, targetRot;
                
                if (stateName === STATE.TREE) {
                    targetPos = this.treePos;
                    targetRot = this.treeRot;
                    // å¦‚æœæ˜¯ç…§ç‰‡ï¼Œåœ¨æ ‘ä¸Šè¦å˜å°
                    if(this.type === 'photo') gsap.to(this.mesh.scale, { x: 1, y: 1, z: 1, duration: 1.5 });
                } else if (stateName === STATE.SCATTER || stateName === STATE.FOCUS) {
                    targetPos = this.scatterPos;
                    targetRot = this.scatterRot;
                    // æ•£å¼€æ—¶ç¨å¾®å˜å¤§ä¸€ç‚¹
                    if(this.type === 'photo' && this.mesh !== focusTarget) {
                         gsap.to(this.mesh.scale, { x: 1.5, y: 1.5, z: 1.5, duration: 1.5 });
                    }
                }

                // ä½¿ç”¨ GSAP å¹³æ»‘ç§»åŠ¨
                if (targetPos) {
                    gsap.to(this.mesh.position, {
                        x: targetPos.x, y: targetPos.y, z: targetPos.z,
                        duration: 2, ease: "power2.inOut"
                    });
                    gsap.to(this.mesh.rotation, {
                        x: targetRot.x, y: targetRot.y, z: targetRot.z,
                        duration: 2, ease: "power2.inOut"
                    });
                }
            }
        }

        function generateParticles() {
            // æ¸…ç†æ—§çš„
            particles.forEach(p => scene.remove(p.mesh));
            particles = [];

            // 1. è£…é¥°çƒ (InstancedMesh æ›´ä¼˜ï¼Œä½†ä¸ºäº†æ··åˆç…§ç‰‡é€»è¾‘ï¼Œè¿™é‡Œç»Ÿä¸€ç”¨Meshæ–¹ä¾¿ç®¡ç†ï¼Œæ•°é‡ä¸å¤šå¯æ¥å—)
            const sphereGeo = new THREE.SphereGeometry(0.3, 16, 16);
            const boxGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const matGold = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.gold, metalness: 0.8, roughness: 0.2, clearcoat: 1.0 });
            const matRed = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.red, metalness: 0.3, roughness: 0.4, emissive: 0x330000 });
            const matGreen = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.green, roughness: 0.8 });

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh;
                const rand = Math.random();
                if (rand > 0.6) mesh = new THREE.Mesh(sphereGeo, matGold);
                else if (rand > 0.3) mesh = new THREE.Mesh(boxGeo, matRed);
                else mesh = new THREE.Mesh(sphereGeo, matGreen);

                particles.push(new ParticleObject(mesh, 'deco'));
            }

            // 2. ç…§ç‰‡å ä½ç¬¦ (å¦‚æœè¿˜æ²¡æœ‰ä¸Šä¼ )
            if (uploadedTextures.length === 0) {
                createPhotoParticles(5, null); // é»˜è®¤5å¼ 
            } else {
                uploadedTextures.forEach(tex => createPhotoParticles(1, tex));
            }
        }

        function createPhotoParticles(count, texture) {
            const geometry = new THREE.PlaneGeometry(2, 2);
            let material;
            
            if (texture) {
                // æ ¹æ®å›¾ç‰‡æ¯”ä¾‹è°ƒæ•´ Plane
                const aspect = texture.image.width / texture.image.height;
                geometry.scale(aspect, 1, 1);
                material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            } else {
                // å ä½ç¬¦æè´¨
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 128;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(0,0,128,128);
                ctx.fillStyle = '#000';
                ctx.font = '20px Arial';
                ctx.fillText('PHOTO', 30, 70);
                const tex = new THREE.CanvasTexture(canvas);
                material = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, color: 0xcccccc });
            }

            for(let i=0; i<count; i++) {
                const mesh = new THREE.Mesh(geometry, material);
                // ç»™ç…§ç‰‡åŠ ä¸ªè¾¹æ¡†
                const border = new THREE.Mesh(new THREE.BoxGeometry(2.1, 2.1, 0.05), new THREE.MeshBasicMaterial({color: 0xFFD700}));
                if(texture) border.scale.set(texture.image.width/texture.image.height, 1, 1);
                mesh.add(border);
                
                particles.push(new ParticleObject(mesh, 'photo'));
            }
        }

        function handleFileUpload(event) {
            const files = event.target.files;
            if (!files.length) return;

            // æ¸…é™¤æ—§çš„â€œé»˜è®¤â€ç…§ç‰‡ï¼Œä¿ç•™è£…é¥°
            particles = particles.filter(p => p.type !== 'photo' || uploadedTextures.length > 0);
            
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        tex.colorSpace = THREE.SRGBColorSpace;
                        uploadedTextures.push(tex);
                        createPhotoParticles(1, tex); // æ¯ä¸Šä¼ ä¸€å¼ åŠ ä¸€ä¸ªç²’å­
                        
                        // åˆ·æ–°å½“å‰çŠ¶æ€ä½ç½®
                        const newP = particles[particles.length-1];
                        newP.updateToState(currentState);
                    }
                };
                reader.readAsDataURL(file);
            });
        }

        // --- é€»è¾‘æ§åˆ¶ ---

        function switchState(newState) {
            if (currentState === newState && newState !== STATE.FOCUS) return;
            currentState = newState;
            
            document.getElementById('mode-text').innerText = newState.toUpperCase();
            showStatus(newState);

            if (newState === STATE.TREE) {
                controls.autoRotate = true;
                gsap.to(camera.position, {x: 0, y: 10, z: 40, duration: 2});
                particles.forEach(p => p.updateToState(STATE.TREE));
                if(focusTarget) focusTarget = null;
            } 
            else if (newState === STATE.SCATTER) {
                controls.autoRotate = false; // æ‰‹åŠ¿æ¥ç®¡æ—‹è½¬
                particles.forEach(p => p.updateToState(STATE.SCATTER));
                if(focusTarget) {
                    gsap.to(focusTarget.scale, {x:1.5, y:1.5, z:1.5, duration: 1}); // è¿˜åŸå¤§å°
                    focusTarget = null;
                }
            }
        }

        function focusOnPhoto(photoMesh) {
            if (currentState === STATE.FOCUS && focusTarget === photoMesh) return;
            currentState = STATE.FOCUS;
            focusTarget = photoMesh;
            showStatus("FOCUS VIEW");

            // 1. ç›¸æœºé£å‘ç…§ç‰‡å‰æ–¹
            const targetPos = new THREE.Vector3();
            photoMesh.getWorldPosition(targetPos);
            const offset = new THREE.Vector3(0, 0, 5); // è·ç¦»ç…§ç‰‡5å•ä½
            offset.applyQuaternion(photoMesh.quaternion);
            const cameraPos = targetPos.clone().add(offset);

            gsap.to(camera.position, {
                x: cameraPos.x, y: cameraPos.y, z: cameraPos.z,
                duration: 1.5,
                onUpdate: () => camera.lookAt(targetPos) // æŒç»­å¯¹ç„¦
            });

            // 2. ç…§ç‰‡æ”¾å¤§å¹¶æ­£é¢æœå‘
            gsap.to(photoMesh.scale, {x: 3, y: 3, z: 3, duration: 1});
            
            // å…¶ä»–ç²’å­é€€åæˆ–å˜æš—ï¼ˆå¯é€‰ï¼Œè¿™é‡Œç®€åŒ–ä¸ºä¸å¤„ç†ï¼‰
        }

        function showStatus(text) {
            const el = document.getElementById('status-indicator');
            el.innerText = text;
            el.style.opacity = 1;
            setTimeout(() => { el.style.opacity = 0; }, 2000);
        }

        // --- MediaPipe é›†æˆ ---
        
        // åŠ¨æ€å¯¼å…¥ MediaPipe
        async function initMediaPipe() {
            const { Hands } = window;
            const { Camera } = window;

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults(onHandsResults);

            const videoElement = document.querySelector('.input_video');
            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            camera.start();
        }

        // æ‰‹åŠ¿é€»è¾‘å¤„ç†
        function onHandsResults(results) {
            const cursor = document.getElementById('hand-cursor');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. è·å–å…³é”®ç‚¹
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const middleTip = landmarks[12];
                const ringTip = landmarks[16];
                const pinkyTip = landmarks[20];
                const wrist = landmarks[0];

                // 2. è®¡ç®—è·ç¦»è¾…åŠ©å‡½æ•°
                const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));

                // 3. è¯†åˆ«â€œæ‹³å¤´â€ (æ‰€æœ‰æŒ‡å°–é è¿‘æ‰‹æŒæ ¹éƒ¨/ä¸­å¿ƒ)
                // ç®€åŒ–åˆ¤æ–­ï¼šæŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»å¾ˆçŸ­
                const isFist = dist(indexTip, wrist) < 0.3 && dist(pinkyTip, wrist) < 0.3;

                // 4. è¯†åˆ«â€œå¼ å¼€â€ (æŒ‡å°–åˆ†æ•£)
                const isOpen = !isFist && dist(indexTip, wrist) > 0.4;

                // 5. è¯†åˆ«â€œæåˆ/æŠ“å–â€ (é£ŸæŒ‡å’Œæ‹‡æŒ‡é è¿‘)
                const isPinch = dist(thumbTip, indexTip) < 0.05;

                // --- æ˜ å°„æ‰‹éƒ¨ä½ç½®åˆ°å±å¹•åæ ‡ (ç”¨äºå…‰æ ‡) ---
                // MediaPipe xåæ ‡æ˜¯ 0-1 (å·¦-å³)ï¼Œä½†å¦‚æœé•œåƒäº†éœ€è¦åè½¬ã€‚CSSä¸­æˆ‘ä»¬å°†Videoé•œåƒäº†ï¼Œæ•°æ®é€šå¸¸ä¸éœ€è¦
                const cursorX = (1 - indexTip.x) * window.innerWidth;
                const cursorY = indexTip.y * window.innerHeight;
                
                cursor.style.display = 'block';
                cursor.style.left = `${cursorX}px`;
                cursor.style.top = `${cursorY}px`;
                
                if (isPinch) cursor.classList.add('pinching');
                else cursor.classList.remove('pinching');

                // æ›´æ–°ç”¨äº Raycaster çš„å½’ä¸€åŒ–åæ ‡ (-1 åˆ° 1)
                mouse.x = ((1 - indexTip.x) * 2) - 1;
                mouse.y = -(indexTip.y * 2) + 1;

                // --- çŠ¶æ€è§¦å‘é€»è¾‘ ---

                if (isFist) {
                    switchState(STATE.TREE);
                } else if (isOpen && !isPinch) {
                    // å¦‚æœåœ¨ TREE çŠ¶æ€ï¼Œåˆ‡æ¢åˆ° SCATTER
                    if (currentState === STATE.TREE) {
                        switchState(STATE.SCATTER);
                    }
                    
                    // å¦‚æœå·²ç»åœ¨ SCATTER çŠ¶æ€ï¼Œè¿›è¡Œæ—‹è½¬äº¤äº’
                    if (currentState === STATE.SCATTER) {
                        // æ ¹æ®æ‰‹çš„ä½ç½®æ—‹è½¬ç›¸æœº
                        const rotationSpeed = 0.02;
                        // æ‰‹åœ¨å±å¹•å·¦ä¾§ï¼Œå‘å·¦è½¬ï¼›å³ä¾§å‘å³è½¬
                        const deltaX = (0.5 - landmarks[9].x) * rotationSpeed; // 9æ˜¯ä¸­æŒ‡æ ¹éƒ¨ï¼Œä»£è¡¨æ‰‹å¿ƒ
                        const deltaY = (0.5 - landmarks[9].y) * rotationSpeed;
                        
                        scene.rotation.y += deltaX * 3;
                        scene.rotation.x += deltaY * 1; 
                    }
                } else if (isPinch) {
                    // æŠ“å–é€»è¾‘
                    if (currentState === STATE.SCATTER || currentState === STATE.FOCUS) {
                        raycaster.setFromCamera(mouse, camera);
                        // åªæ£€æµ‹ Photo ç±»å‹çš„ Mesh
                        const photoMeshes = particles
                            .filter(p => p.type === 'photo')
                            .map(p => p.mesh);
                        
                        const intersects = raycaster.intersectObjects(photoMeshes);
                        
                        if (intersects.length > 0) {
                            focusOnPhoto(intersects[0].object);
                        }
                    }
                }

            } else {
                cursor.style.display = 'none';
                // å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼Œæ¢å¤è‡ªåŠ¨æ—‹è½¬ï¼ˆä»…åœ¨Treeæ¨¡å¼ä¸‹ï¼‰
                if(currentState === STATE.TREE) controls.autoRotate = true;
            }
        }

        // --- æ¸²æŸ“å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // å¦‚æœæ˜¯è‡ªåŠ¨æ—‹è½¬
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // å¯åŠ¨
        init();
        
        // å»¶è¿ŸåŠ è½½ MediaPipe ä»¥ç¡®ä¿ DOM å°±ç»ª
        setTimeout(() => {
            // æ³¨æ„ï¼šMediaPipe åº“æ¯”è¾ƒå¤§ï¼ŒåŠ è½½éœ€è¦æ—¶é—´
            console.log("Loading MediaPipe...");
            initMediaPipe(); 
        }, 1000);

    </script>
</body>
</html>