<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Gesture Christmas Tree - Fixed</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }
        .hud-text {
            color: #FFD700; text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            text-transform: uppercase; letter-spacing: 2px; font-size: 12px; font-weight: bold;
        }
        #controls { pointer-events: auto; text-align: center; margin-bottom: 80px;}
        .upload-btn {
            background: rgba(47, 79, 79, 0.8); border: 1px solid #FFD700; color: #FFD700;
            padding: 12px 24px; cursor: pointer; font-weight: bold; transition: 0.3s;
            pointer-events: auto; display: inline-block; border-radius: 4px;
        }
        #hand-cursor {
            position: absolute; width: 25px; height: 25px; border: 2px solid #FFD700; border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 1000;
            box-shadow: 0 0 15px #FFD700; background: rgba(255, 215, 0, 0.2);
        }
        .input_video {
            position: absolute; top: 15px; right: 15px; width: 120px; height: 90px; 
            border: 1px solid rgba(255, 215, 0, 0.4); border-radius: 8px; opacity: 0.7; transform: scaleX(-1);
        }
    </style>
</head>
<body>

    <video class="input_video" playsinline></video>
    
    <div id="ui-layer">
        <div class="hud-text">Status: <span id="mode-text">Connecting Camera...</span></div>
        <div id="controls">
            <label class="upload-btn">
                ğŸ“¸ ä¸Šä¼ ç…§ç‰‡è£…ç‚¹
                <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
            </label>
            <div class="hud-text" style="margin-top:15px; font-size: 10px; opacity: 0.7;">
                ğŸ– å¼ å¼€: å‡èšæˆæ ‘ | âœŠ æåˆ: æ•£ä½œæ˜Ÿè¾°
            </div>
        </div>
    </div>

    <div id="hand-cursor"></div>
    <div id="canvas-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import gsap from 'gsap';

        let scene, camera, renderer, composer, snowSystem;
        let particles = [];
        let currentState = 'tree';

        // åˆå§‹åŒ–åœºæ™¯
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 12, 45);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // åæœŸå¤„ç†ï¼šå‘å…‰æ•ˆæœ
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            
            createSnow();
            createTreeParticles();
            initMediaPipe();

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // åˆ›å»ºé›ªèŠ±
        function createSnow() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            for (let i = 0; i < 1500; i++) {
                vertices.push(Math.random() * 100 - 50, Math.random() * 100 - 50, Math.random() * 100 - 50);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0.6 });
            snowSystem = new THREE.Points(geometry, material);
            scene.add(snowSystem);
        }

        // åˆ›å»ºæ ‘ç²’å­
        function createTreeParticles() {
            const sphereGeom = new THREE.SphereGeometry(0.25, 6, 6);
            for (let i = 0; i < 400; i++) {
                let color = (i % 5 === 0) ? 0xFFD700 : (i % 8 === 0 ? 0x8B0000 : 0x2F4F4F);
                const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
                const mesh = new THREE.Mesh(sphereGeom, mat);
                
                // è®¡ç®—åœ£è¯æ ‘åœ†é”¥ä½ç½®
                const y = (Math.random() * 30) - 10;
                const r = (1 - (y + 10) / 30) * 12 + 0.5;
                const theta = y * 1.2 + Math.random() * Math.PI * 2;
                
                mesh.userData.treePos = new THREE.Vector3(r * Math.cos(theta), y, r * Math.sin(theta));
                mesh.userData.scatterPos = new THREE.Vector3((Math.random()-0.5)*60, (Math.random()-0.5)*60, (Math.random()-0.5)*60);
                
                mesh.position.copy(mesh.userData.treePos);
                scene.add(mesh);
                particles.push(mesh);
            }
        }

        // çŠ¶æ€åˆ‡æ¢åŠ¨ç”»
        function switchState(next) {
            if (currentState === next) return;
            currentState = next;
            document.getElementById('mode-text').innerText = next === 'tree' ? "TREE MODE" : "SCATTER MODE";
            
            particles.forEach((p, i) => {
                const target = next === 'tree' ? p.userData.treePos : p.userData.scatterPos;
                gsap.to(p.position, {
                    x: target.x, y: target.y, z: target.z,
                    duration: 1.5 + Math.random(),
                    ease: "power2.inOut",
                    delay: i * 0.001
                });
            });
        }

        // æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
        async function initMediaPipe() {
            const videoElement = document.querySelector('.input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            hands.onResults((results) => {
                const cursor = document.getElementById('hand-cursor');
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const pts = results.multiHandLandmarks[0];
                    const indexTip = pts[8];
                    const thumbTip = pts[4];
                    
                    cursor.style.display = 'block';
                    cursor.style.left = (1 - indexTip.x) * window.innerWidth + 'px';
                    cursor.style.top = indexTip.y * window.innerHeight + 'px';

                    const dist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                    // é˜ˆå€¼è®¾ä¸º0.07ï¼Œå¢åŠ åˆ¤å®šç¨³å®šæ€§
                    if (dist < 0.07) switchState('scatter');
                    else switchState('tree');
                } else {
                    cursor.style.display = 'none';
                }
            });

            const cameraPipe = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraPipe.start();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (snowSystem) {
                snowSystem.rotation.y += 0.001;
                const pos = snowSystem.geometry.attributes.position.array;
                for(let i=1; i<pos.length; i+=3) {
                    pos[i] -= 0.05;
                    if(pos[i] < -30) pos[i] = 30;
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            if (currentState === 'tree') scene.rotation.y += 0.005;
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
